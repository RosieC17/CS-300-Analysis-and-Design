# CS-300-Analysis-and-Design

Project Reflections
1. What was the problem you were solving in the projects for this course?

In Project One, I explored how different data structures perform in terms of run-time and memory usage. The goal was to understand which structures work best in different scenarios. Project Two focused on a more practical task: sorting and displaying a list of Computer Science courses in alphanumeric order. Together, these projects gave me a deeper appreciation for how data structures and algorithms affect the efficiency and organization of a program.

2. How did you approach the problem?

I started by breaking each problem into smaller steps. For Project One, I analyzed operations like insertion, deletion, and searching across multiple data structures, paying attention to both speed and memory. For Project Two, I applied sorting algorithms and organized the course data so it could be displayed clearly. Learning the theory behind each structure helped me make informed choices and write efficient code.

3. How did you overcome any roadblocks?

I ran into challenges when optimizing code and making sure the sorted output was correct. I tackled these roadblocks by revisiting the concepts, researching best practices, and testing different approaches. Taking the problems step by step helped me find mistakes and refine my solutions effectively.

4. How has your work on this project expanded your approach to designing software?

These projects taught me the importance of selecting the right data structure early in the design process. They also showed me how thinking about performance and memory usage upfront can save time and make programs more robust. Now, I approach software design with efficiency and scalability in mind from the very beginning.

5. How has your work on this project evolved the way you write programs?

Iâ€™ve become more intentional about writing code that is readable, maintainable, and adaptable. I focus on clear structure, meaningful variable names, and modular design. Including comments and thinking ahead about future changes makes my code easier to maintain and extend, which is crucial for real-world projects.
